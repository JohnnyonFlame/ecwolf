//
// WL_MENU.H
//

#ifndef __WL_MENU_H__
#define __WL_MENU_H__

#include <string>
#include <vector>

/*//////////////////////////////////////////////////////////////////////////////
//                         NEW MENU CODE
//
// The new menu code is an object oriented approach to the menu.  Each option
// has its own object which function is determined by the class used.  The base
// class, MenuItem, can be inherited for reusable types or controled through a
// listener which is a function whose prototype is produced with MENU_LISTENER.
//
//                        ABOUT LISTENERS
//
// A listener is a function which has a special prototype which is generated by
// MENU_LISTENER.  Simply pass the name of the listener into the macro to begin
// your function.  Pass the name of the listener into an object to use.  The
// return type is bool so be sure to return true.  (Return false when something
// is supposed to fail, but remember only some item types use the return value
// (read the docs to figure out when it is used.).)
//////////////////////////////////////////////////////////////////////////////*/

class Menu;

#define MENU_LISTENER(name)				bool name(int which)
#define MENU_LISTENER_PROTOTYPE(name)	bool (*name)(int)
class MenuItem
{
	protected:
		MENU_LISTENER_PROTOTYPE(activateListener);
		bool		enabled;
		int			height;
		bool		highlight; // Makes the font a different color, not to be confused with the item being selected.
		int			picture;
		int			pictureX;
		int			pictureY;
		bool		selected;
		char		string[36];
		bool		visible;
		const Menu	*menu;

		void		setTextColor();

	public:
				MenuItem(const char string[36], MENU_LISTENER_PROTOTYPE(activateListener)=NULL);
		virtual	~MenuItem() {}

		const short	getActive() const { return enabled ? (highlight ? 2 : 1) : 0; }
		int			getHeight() const { return visible ? height : 0; }
		const char	*getString() const { return string; }
		bool		isEnabled() const { return enabled; }
		bool		isHighlighted() const { return highlight; }
		bool		isSelected() const { return selected; }
		bool		isVisible() const { return visible; }
		void		setActivateListener(MENU_LISTENER_PROTOTYPE(activateListener)) { this->activateListener = activateListener; }
		void		setEnabled(bool enabled=true) { this->enabled = enabled; }
		void		setHighlighted(bool highlight=true) {this->highlight = highlight; }
		void		setMenu(const Menu *menu) { this->menu = menu; }
		void		setPicture(int picture, int x=-1, int y=-1);
		void		setSelected(bool selected=true) {this->selected = selected; }
		void		setText(const char string[36]);
		void		setVisible(bool visible=true) { this->visible = visible; }

		virtual void	activate();
		virtual void	draw();
		virtual void	left() {}
		virtual void	right() {}
};

class LabelMenuItem : public MenuItem
{
	public:
		LabelMenuItem(const char string[36]);

		void draw();
};

class BooleanMenuItem : public MenuItem
{
	protected:
		boolean	&value;

	public:
		BooleanMenuItem(const char string[36], boolean &value, MENU_LISTENER_PROTOTYPE(activateListener)=NULL);

		void	activate();
		void	draw();
};

class FunctionMenuItem : public MenuItem
{
	protected:
		bool	fadeEnabled;
		int		(*function)(int);

	public:
		FunctionMenuItem(const char string[36], int (*function)(int), bool fadeEnabled=true);

		void	activate();
		void	setEnableFade(bool fadeEnabled=true) { this->fadeEnabled = fadeEnabled; }
};

class MenuSwitcherMenuItem : public MenuItem
{
	protected:
		Menu	&menu;

	public:
		/**
		 * @param activateListener Executes when activated.  If returns false, menu will not switch.
		 */
		MenuSwitcherMenuItem(const char string[36], Menu &menu, MENU_LISTENER_PROTOTYPE(activateListener)=NULL);

		void	activate();
};

class SliderMenuItem : public MenuItem
{
	protected:
		char		begString[36];
		int			&value;
		const int	width;
		const int	max;

	public:
		SliderMenuItem(int &value, int width, int max, const char begString[36]="", const char endString[36]="");

		void	draw();
		void	left();
		void	right();
};

class MultipleChoiceMenuItem : public MenuItem
{
	protected:
		int			curOption;
		const int	numOptions;
		char**		options;

	public:
		/**
		 * @param options Name of the possible options.  Use NULL to indicate a disabled option as to keep the positions correct.
		 */
		MultipleChoiceMenuItem(MENU_LISTENER_PROTOTYPE(changeListener), const char** options, int numOptions, int curOption=0);
		~MultipleChoiceMenuItem();

		void	activate();
		void	draw();
		void	left();
		void	right();
};

class TextInputMenuItem : public MenuItem
{
	protected:
		unsigned int	max;
		MENU_LISTENER_PROTOTYPE(preeditListener);
		std::string		value;

	public:
		/**
		 * @param preeditListener Executed before editing the information, if returns false the field will not be edited.
		 * @param posteditListener Execued after editing the information.
		 */
		TextInputMenuItem(std::string text, unsigned int max, MENU_LISTENER_PROTOTYPE(preeditListener)=NULL, MENU_LISTENER_PROTOTYPE(posteditListener)=NULL);

		void		activate();
		void		draw();
		const char	*getValue() { return value.c_str(); }
		void		setValue(std::string text) { value = text; }
};

class Menu
{
	protected:
		MENU_LISTENER_PROTOTYPE(entryListener);
		static bool				close;
		int						curPos;
		int						headPicture;
		char					headText[36];
		int						height;
		const int				indent;
		std::vector<MenuItem *>	items;
		const int				x;
		const int				y;
		const int				w;

		void	drawGun(int x, int &y, int which, int basey);
		void	eraseGun(int x, int y, int which);

	public:
		Menu(int x, int y, int w, int indent, MENU_LISTENER_PROTOTYPE(entryListener)=NULL);
		~Menu();

		void			addItem(MenuItem *item);
		static bool		areMenusClosed() { return close; }
		static void		closeMenus(bool close=true) { Menu::close = close; }
		unsigned int	countItems() const;
		void			drawMenu() const;
		void			draw() const;
		int				handle();
		int				getCurrentPosition() const { return curPos; }
		/**
		 * @param position If not -1, returns the height to the specified position.
		 */
		int				getHeight(int position=-1) const;
		int				getIndent() const { return indent; }
		MenuItem		*getIndex(int index) const;
		int				getWidth() const { return w; }
		int				getX() const { return x; }
		int				getY() const { return y; }
		void			setHeadPicture(int picture) { headPicture = picture; }
		void			setHeadText(const char text[36]);
		void			show();
		MenuItem		*operator[] (int index) { return getIndex(index); }
};

extern Menu	mainMenu;

#ifdef SPEAR

#define BORDCOLOR       0x99
#define BORD2COLOR      0x93
#define DEACTIVE        0x9b
#define BKGDCOLOR       0x9d
//#define STRIPE                0x9c

#define MenuFadeOut()   VL_FadeOut(0,255,0,0,51,10)

#else

#define BORDCOLOR       0x29
#define BORD2COLOR      0x23
#define DEACTIVE        0x2b
#define BKGDCOLOR       0x2d
#define STRIPE          0x2c

#define MenuFadeOut()   VL_FadeOut(0,255,43,0,0,10)

#endif

#define READCOLOR       0x4a
#define READHCOLOR      0x47
#define VIEWCOLOR       0x7f
#define TEXTCOLOR       0x17
#define HIGHLIGHT       0x13
#define MenuFadeIn()    VL_FadeIn(0,255,gamepal,10)


#define MENUSONG        WONDERIN_MUS

#ifndef SPEAR
#define INTROSONG       NAZI_NOR_MUS
#else
#define INTROSONG       XTOWER2_MUS
#endif

#define SENSITIVE       60
#define CENTERX         ((int) screenWidth / 2)
#define CENTERY         ((int) screenHeight / 2)

#define MENU_X  76
#define MENU_Y  55
#define MENU_W  178
#ifndef SPEAR
#ifndef GOODTIMES
#define MENU_H  13*10+6
#else
#define MENU_H  13*9+6
#endif
#else
#define MENU_H  13*9+6
#endif

#define SM_X    48
#define SM_W    250

#define SM_Y1   20
#define SM_H1   4*13-7
#define SM_Y2   SM_Y1+5*13
#define SM_H2   4*13-7
#define SM_Y3   SM_Y2+5*13
#define SM_H3   3*13-7

#define CTL_X   24
#define CTL_Y   86
#define CTL_W   284
#define CTL_H   75

#define LSM_X   85
#define LSM_Y   55
#define LSM_W   175
#define LSM_H   10*13+10

#define NM_X    50
#define NM_Y    100
#define NM_W    225
#define NM_H    13*4+15

#define NE_X    10
#define NE_Y    23
#define NE_W    320-NE_X*2
#define NE_H    200-NE_Y*2

#define CST_X           20
#define CST_Y           48
#define CST_START       60
#define CST_SPC 60


//
// TYPEDEFS
//
typedef struct {
                short x,y,amount,curpos,indent;
                } CP_iteminfo;

typedef struct {
                short active;
                char string[36];
                int (* routine)(int temp1);
                } CP_itemtype;

typedef struct {
                short allowed[4];
                } CustomCtrls;

//
// FUNCTION PROTOTYPES
//

void CreateMenus();

void US_ControlPanel(ScanCode);

void SetupControlPanel(void);
void SetupSaveGames();
void CleanupControlPanel(void);

void DrawMenu(CP_iteminfo *item_i,CP_itemtype *items);
int  HandleMenu(CP_iteminfo *item_i,
                CP_itemtype *items,
                void (*routine)(int w));
void ClearMScreen(void);
void DrawWindow(int x,int y,int w,int h,int wcolor);
void DrawOutline(int x,int y,int w,int h,int color1,int color2);
void WaitKeyUp(void);
void ReadAnyControl(ControlInfo *ci);
void TicDelay(int count);
void CacheLump(int lumpstart,int lumpend);
void UnCacheLump(int lumpstart,int lumpend);
int StartCPMusic(int song);
int  Confirm(const char *string);
void Message(const char *string);
void CheckPause(void);
void ShootSnd(void);
void CheckSecretMissions(void);
void BossKey(void);

void DrawGun(CP_iteminfo *item_i,CP_itemtype *items,int x,int *y,int which,int basey,void (*routine)(int w));
void DrawHalfStep(int x,int y);
void EraseGun(CP_iteminfo *item_i,CP_itemtype *items,int x,int y,int which);
void SetTextColor(CP_itemtype *items,int hlight);
void DrawMenuGun(CP_iteminfo *iteminfo);
void DrawStripes(int y);

void DefineMouseBtns(void);
void DefineJoyBtns(void);
void DefineKeyBtns(void);
void DefineKeyMove(void);
void EnterCtrlData(int index,CustomCtrls *cust,void (*DrawRtn)(int),void (*PrintRtn)(int),int type);

void DrawLoadSaveScreen(int loadsave);
void DrawChangeView(int view);
void DrawCustomScreen(void);
void DrawLSAction(int which);
void DrawCustMouse(int hilight);
void DrawCustJoy(int hilight);
void DrawCustKeybd(int hilight);
void DrawCustKeys(int hilight);
void PrintCustMouse(int i);
void PrintCustJoy(int i);
void PrintCustKeybd(int i);
void PrintCustKeys(int i);

void PrintLSEntry(int w,int color);
void TrackWhichGame(int w);
void DrawNewGameDiff(int w);
void FixupCustom(int w);

int  CP_LoadGame(int quick);
int  CP_SaveGame(int quick);
int CP_Control(int);
int CP_ChangeView(int);
int CP_ExitOptions(int);
int  CP_EndGame(int);
int  CP_CheckQuick(ScanCode scancode);
int CustomControls(int);

void CheckForEpisodes(void);

void FreeMusic(void);


enum {MOUSE,JOYSTICK,KEYBOARDBTNS,KEYBOARDMOVE};        // FOR INPUT TYPES

//
// WL_INTER
//
typedef struct {
                int kill,secret,treasure;
                int32_t time;
                } LRstruct;

extern LRstruct LevelRatios[];

void Write (int x,int y,const char *string);
void NonShareware(void);
int GetYorN(int x,int y,int pic);

#endif
